<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Reflective Sphere — 360° (HDRI)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#0b0e13;color:#e5e7eb;font-family:system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif}
    #app{position:fixed;inset:0;display:grid;grid-template-columns:minmax(280px,360px) 1fr}
    #ui{padding:16px 18px;background:linear-gradient(180deg,#0d1117 0%,#0b0e13 100%);border-right:1px solid #1f2937;overflow:auto}
    h1{font-size:16px;margin:0 0 10px;color:#cbd5e1}
    .sub{font-size:12px;color:#94a3b8;margin-bottom:14px;line-height:1.35}
    .group{background:#121620;border:1px solid #1f2937;border-radius:14px;padding:12px;margin-bottom:14px;box-shadow:0 10px 30px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.02)}
    .row{display:grid;grid-template-columns:1fr auto;align-items:center;gap:10px;margin:8px 0}
    label{font-size:12px;color:#cbd5e1}
    input[type="range"]{width:100%}
    .val{font-variant-numeric:tabular-nums;font-size:12px;color:#94a3b8}
    select,input[type="file"]{width:100%;padding:8px 10px;border-radius:10px;border:1px solid #243042;background:#0f1420;color:#e5e7eb}
    .btn{width:100%;padding:10px 12px;border-radius:12px;border:1px solid #1f2937;background:#0f172a;color:#e2e8f0;cursor:pointer}
    .btn:hover{border-color:#334155}
    #canvas{position:relative}
    #credits{position:absolute;left:12px;bottom:10px;font-size:12px;color:#94a3b8;background:rgba(0,0,0,.4);padding:6px 8px;border-radius:10px}
    #status{position:absolute;left:12px;top:10px;font-size:12px;background:rgba(0,0,0,.5);padding:6px 8px;border-radius:10px;color:#a5b4fc}
    .accent{color:#7dd3fc}
  </style>
</head>
<body>
  <h2>My Experiments</h2>
<ul>
  <li><a href="golf_pairings_randomizer.html">Golf Pairings Randomizer</a></li>
  <li><a href="montyhall.html">Monty Hall Game</a></li>
  <li><a href="piano.html">Virtual Piano</a></li>
  <li><a href="reflective_sphere_360.html">Reflective Sphere</a></li>
</ul>

<div id="app">
  <aside id="ui">
    <h1>Reflective Sphere — 360°</h1>
    <div class="sub">Drag to look around. The sphere reflects the HDRI/360 panorama. You can also load your own .hdr or JPG/PNG.</div>

    <div class="group">
      <label for="preset">Background</label>
      <select id="preset">
        <option value="venice" selected>Venice Sunset HDRI (default)</option>
        <option value="parkJpg">City Park (JPG)</option>
        <option value="bridgeJpg">Under Bridge (JPG)</option>
      </select>
      <div style="height:8px"></div>
      <input id="file" type="file" accept=".hdr,image/*" />
      <div class="sub">Tip: Use equirectangular 360s (2:1). .hdr gives the nicest reflections.</div>
    </div>

    <div class="group">
      <div class="row"><label for="metalness">Metalness</label><span class="val" id="metalnessVal">1.00</span></div>
      <input id="metalness" type="range" min="0" max="1" step="0.01" value="1" />
      <div class="row"><label for="roughness">Roughness</label><span class="val" id="roughnessVal">0.02</span></div>
      <input id="roughness" type="range" min="0" max="1" step="0.01" value="0.02" />
      <div class="row"><label for="clearcoat">Clearcoat</label><span class="val" id="clearcoatVal">0.30</span></div>
      <input id="clearcoat" type="range" min="0" max="1" step="0.01" value="0.30" />
      <div class="row"><label for="ccr">Clearcoat Roughness</label><span class="val" id="ccrVal">0.10</span></div>
      <input id="ccr" type="range" min="0" max="1" step="0.01" value="0.10" />
      <div class="row"><label for="ior">Index of Refraction</label><span class="val" id="iorVal">1.45</span></div>
      <input id="ior" type="range" min="1" max="2.333" step="0.001" value="1.45" />
    </div>

    <div class="group">
      <div class="row"><label for="height">Sphere height</label><span class="val" id="heightVal">1.20 m</span></div>
      <input id="height" type="range" min="0.1" max="3" step="0.01" value="1.2" />
      <div class="row"><label for="size">Sphere size</label><span class="val" id="sizeVal">0.50 m</span></div>
      <input id="size" type="range" min="0.1" max="2" step="0.01" value="0.5" />
      <div class="row"><label for="shadow">Shadow strength</label><span class="val" id="shadowVal">0.60</span></div>
      <input id="shadow" type="range" min="0" max="1" step="0.01" value="0.6" />
      <button class="btn" id="reset">Reset View</button>
    </div>
  </aside>

  <main id="canvas">
    <div id="status">Loading…</div>
    <div id="credits">Drag to rotate • Scroll to zoom • <span class="accent">Reflective</span> PBR sphere</div>
  </main>
</div>

<script type="module">
  // Single-source imports to avoid "multiple instances" warning
  import * as THREE from "https://esm.sh/three@0.160.0";
  import { OrbitControls } from "https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js";
  import { RGBELoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/RGBELoader.js";

  const statusEl = document.getElementById('status');
  const container = document.getElementById('canvas');

  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  container.appendChild(renderer.domElement);

  // Scene & Camera
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(65, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.set(0, 1.2, 3);

  // Controls
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.target.set(0, 1.2, 0);

  // Subtle grid + fake shadow
  //const grid = new THREE.GridHelper(10, 60, 0x1f2937, 0x0f172a);
  //grid.material.opacity = 0.25; grid.material.transparent = true; scene.add(grid);

  const shadowTex = (() => {
    const c = document.createElement('canvas'), size = 512;
    c.width = c.height = size;
    const ctx = c.getContext('2d');
    const g = ctx.createRadialGradient(size/2,size/2,size*0.15,size/2,size/2,size*0.48);
    g.addColorStop(0,'rgba(0,0,0,0.45)'); g.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle = g; ctx.fillRect(0,0,size,size);
    const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace; return tex;
  })();
  const shadowMat = new THREE.MeshBasicMaterial({ map: shadowTex, transparent: true, depthWrite: false, opacity: 0.6 });
  const shadowPlane = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 3.5), shadowMat);
  shadowPlane.rotation.x = -Math.PI/2; shadowPlane.position.y = 0.001; scene.add(shadowPlane);

  // Sphere (mirror-like defaults for HDRI)
  const sphereGeom = new THREE.SphereGeometry(0.5, 128, 128);
  const sphereMat = new THREE.MeshPhysicalMaterial({
    color: 0xffffff, metalness: 1.0, roughness: 0.02, clearcoat: 0.30, clearcoatRoughness: 0.10, ior: 1.45
  });
  const sphere = new THREE.Mesh(sphereGeom, sphereMat);
  sphere.position.set(0, 1.2, 0);
  scene.add(sphere);

  // PMREM for filtered environment
  const pmrem = new THREE.PMREMGenerator(renderer);

  // --- Background/env loaders ---
  const PRESETS = {
    // Venice HDRI from the Three.js repo
    venice: "https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/venice_sunset_1k.hdr",
    // JPG fallbacks (LDR) from the Three.js repo
    parkJpg:   "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/equirectangular/park.jpg",
    bridgeJpg: "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/equirectangular/2294472375_24a3b8ef46_o.jpg"
  };

  function setStatus(t){ statusEl.textContent = t; }

  function applyEnvFromTexture(tex){
    // For JPG/PNG: map background and build env
    const envRT = pmrem.fromEquirectangular(tex);
    scene.environment = envRT.texture;
    scene.background = tex; // show panorama behind
    setStatus("Loaded ✔");
  }

  function loadHDR(url){
    setStatus("Loading HDRI…");
    new RGBELoader().load(url, (hdrTex)=>{
      hdrTex.mapping = THREE.EquirectangularReflectionMapping;
      // Use HDRI as background (tone-mapped) and as env via PMREM
      scene.background = hdrTex;
      const envRT = pmrem.fromEquirectangular(hdrTex);
      scene.environment = envRT.texture;
      setStatus("HDRI loaded ✔");
    }, undefined, ()=>{
      setStatus("Couldn’t load HDRI — using fallback.");
      applyEnvFromTexture(makeFallbackEquirect());
    });
  }

  function loadLDR(url){
    setStatus("Loading image…");
    new THREE.TextureLoader().load(url, (tex)=>{
      tex.mapping = THREE.EquirectangularReflectionMapping;
      tex.colorSpace = THREE.SRGBColorSpace;
      applyEnvFromTexture(tex);
    }, undefined, ()=>{
      setStatus("Couldn’t load image — using fallback.");
      applyEnvFromTexture(makeFallbackEquirect());
    });
  }

  // Procedural fallback (2:1 equirect)
  function makeFallbackEquirect(){
    const w=1024,h=512,c=document.createElement('canvas'); c.width=w; c.height=h;
    const ctx=c.getContext('2d'), g=ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,'#2a3a5f'); g.addColorStop(1,'#0b0e13'); ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
    ctx.fillStyle='rgba(255,255,255,0.05)'; ctx.fillRect(0,h*0.48,w,h*0.04);
    const tex=new THREE.CanvasTexture(c); tex.colorSpace=THREE.SRGBColorSpace; tex.mapping=THREE.EquirectangularReflectionMapping; return tex;
  }

  // ---- UI wiring ----
  const $ = (id)=>document.getElementById(id);
  const metalness=$('metalness'), roughness=$('roughness'), clearcoat=$('clearcoat'),
        ccr=$('ccr'), ior=$('ior'), height=$('height'), size=$('size'), shadow=$('shadow'),
        preset=$('preset'), file=$('file');

  function setLabel(id, t){ $(id).textContent = t; }
  function updateMaterial(){
    sphere.material.metalness = +metalness.value;
    sphere.material.roughness = +roughness.value;
    sphere.material.clearcoat = +clearcoat.value;
    sphere.material.clearcoatRoughness = +ccr.value;
    sphere.material.ior = +ior.value;
    setLabel('metalnessVal', metalness.value);
    setLabel('roughnessVal', roughness.value);
    setLabel('clearcoatVal', clearcoat.value);
    setLabel('ccrVal', ccr.value);
    setLabel('iorVal', ior.value);
  }
  function updateTransform(){
    sphere.position.y = +height.value;
    const r = +size.value; sphere.scale.setScalar(r / 0.5);
    setLabel('heightVal', height.value + ' m'); setLabel('sizeVal', size.value + ' m');
    shadowPlane.material.opacity = +shadow.value; setLabel('shadowVal', shadow.value);
  }
  [metalness,roughness,clearcoat,ccr,ior].forEach(el=>el.addEventListener('input',updateMaterial));
  [height,size,shadow].forEach(el=>el.addEventListener('input',updateTransform));
  $('reset').addEventListener('click',()=>{ camera.position.set(0,1.2,3); controls.target.set(0,1.2,0); controls.update(); });

  preset.addEventListener('change', ()=>{
    const v = preset.value;
    if (v === 'venice') loadHDR(PRESETS.venice);
    else if (v === 'parkJpg') loadLDR(PRESETS.parkJpg);
    else if (v === 'bridgeJpg') loadLDR(PRESETS.bridgeJpg);
  });

  file.addEventListener('change', (e)=>{
    const f = e.target.files[0]; if(!f) return;
    const isHdr = /\.hdr$/i.test(f.name);
    if (isHdr) {
      setStatus("Loading HDRI from file…");
      new RGBELoader().load(URL.createObjectURL(f), (hdrTex)=>{
        hdrTex.mapping = THREE.EquirectangularReflectionMapping;
        scene.background = hdrTex;
        const envRT = pmrem.fromEquirectangular(hdrTex);
        scene.environment = envRT.texture;
        setStatus("HDRI loaded ✔");
      }, undefined, ()=>{ setStatus("HDR load failed — using fallback."); applyEnvFromTexture(makeFallbackEquirect()); });
    } else {
      setStatus("Loading image from file…");
      const img = new Image();
      img.onload = ()=>{
        const tex = new THREE.Texture(img); tex.needsUpdate = true;
        tex.mapping = THREE.EquirectangularReflectionMapping; tex.colorSpace = THREE.SRGBColorSpace;
        applyEnvFromTexture(tex);
      };
      img.src = URL.createObjectURL(f);
    }
  });

  // Resize
  addEventListener('resize', ()=>{
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
  });

  // Start
  updateMaterial(); updateTransform();
  loadHDR(PRESETS.venice);

  (function animate(){ controls.update(); renderer.render(scene,camera); requestAnimationFrame(animate); })();
</script>
</body>
</html>

